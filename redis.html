<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="//cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
    <link rel="stylesheet" href="//cdn.staticfile.org/highlight.js/11.2.0/styles/default.min.css">
    <link rel="stylesheet" href="//cdn.staticfile.org/gitalk/1.7.2/gitalk.css">
    <link rel="stylesheet" href="/markhtml.css">
    <title>Index</title>
</head>

<body>
    <div id="navbar"></div>
    <div id="menu"></div>
    <div class="markdown-body main" id="app">
<!---
markmeta_author: wongoo
markmeta_date: 2019-12-27
markmeta_title: redis 总结
markmeta_categories: db
markmeta_tags: redis
-->

<h1 id="redis-总结">redis 总结</h1>
<p>Redis(Remote Dictionary Server) 本质上是一个Key-Value类型的内存数据库。</p>
<p>整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作。</p>
<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB.</p>
<p>另外Redis也可以对存入的Key-Value设置expire时间。 </p>
<h2 id="性能">性能</h2>
<p>redis单节点性能</p>
<ul>
<li>单命令并发可达 10w TPS </li>
<li>管道及多指令可达 50w TPS </li>
<li>单命令时延在 150 us 左右</li>
</ul>
<h2 id="缓存">缓存</h2>
<ul>
<li>缓存一致性： 难以保证绝对一致性, 但可以最终一致性<ul>
<li>write db -&gt; evict cache</li>
<li>evit cache -&gt; write db -&gt; evit cache</li>
<li>binlog 更新</li>
</ul>
</li>
<li>缓存穿透： 访问一个不存在的key<ul>
<li>在缓存中加入该key的null值</li>
<li>bloomfilter</li>
</ul>
</li>
<li>缓存击穿: 大量请求未缓存的key<ul>
<li>实现redis分段锁, 同样的请求争夺一把锁</li>
<li>拿到锁的去数据库查询 未拿到锁的等待, 再尝试访问缓存</li>
<li>缓存中还没有数据, 尝试数据库拿取</li>
</ul>
</li>
<li>缓存雪崩: 大量key的失效</li>
</ul>
<h2 id="redis-的线程模型">redis 的线程模型</h2>
<p>redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。
它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h2 id="redis支持数据类型">Redis支持数据类型</h2>
<p>String、List、Set、Sorted Set、hashes、bitmaps、hyperloglogs、geospatial indexes</p>
<h2 id="redis数据淘汰策略">Redis数据淘汰策略</h2>
<ul>
<li>noeviction: 返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li>allkeys-lru: 尝试回收最少使用的键（LRU）。</li>
<li>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键。</li>
<li>allkeys-random: 回收随机的键。</li>
<li>volatile-random: 回收随机的键，但仅限于在过期集合的键。</li>
<li>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键</li>
<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ul>
<h2 id="过期删除">过期删除</h2>
<ul>
<li>定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li>
</ul>
<h2 id="一个字符串类型的值能存储最大容量是多少？-512m">一个字符串类型的值能存储最大容量是多少？ 512M</h2>
<h2 id="redis是单线程的，如何提高多核cpu的利用率？">Redis是单线程的，如何提高多核CPU的利用率？</h2>
<p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h2 id="一个redis实例最多能存放多少的keys？list、set、sorted-set他们最多能存放多少元素？">一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</h2>
<p>理论上Redis可以处理多达2^32的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。
任何list、set、和sorted set都可以放2^32个元素。
换句话说，Redis的存储极限是系统中的可用内存值。</p>
<h2 id="redis常见性能问题和解决方案？">Redis常见性能问题和解决方案？</h2>
<ol>
<li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li>
<li>尽量避免在压力很大的主库上增加从库</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li>
</ol>
<h2 id="redis提供了哪几种持久化方式？">Redis提供了哪几种持久化方式？</h2>
<p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.
Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</p>
<p>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.
最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。</p>
<h2 id="如何选择合适的持久化方式？">如何选择合适的持久化方式？</h2>
<p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。
有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 
并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快。</p>
<h2 id="什么是缓存穿透？如何避免？">什么是缓存穿透？如何避免？</h2>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。
一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<ol>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点。</li>
<li>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</li>
</ol>
<h2 id="什么是缓存雪崩？何如避免？">什么是缓存雪崩？何如避免？</h2>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>如何避免？</p>
<ol>
<li>加锁或限流；</li>
<li>二级缓存；</li>
<li>不同的key，设置不同的过期时间，让缓存均匀失效。</li>
</ol>
<h2 id="优化的一些建议">优化的一些建议</h2>
<ul>
<li>尽量使用短的key</li>
<li>避免使用keys *</li>
<li>在存到Redis之前先把你的数据压缩下</li>
<li>设置 key 有效期</li>
<li>选择回收策略(maxmemory-policy)</li>
<li>使用bit位级别操作和byte字节级别操作来减少不必要的内存使用。</li>
<li>尽可能地使用hashes哈希存储。</li>
<li>想要一次添加多条数据的时候可以使用管道。</li>
<li>限制redis的内存大小</li>
<li>SLOWLOG 记录分析</li>
<li>linux tcp 连接参数优化</li>
</ul>

</div>
<div class="main" id="gitalk"></div>
<script src="//cdn.staticfile.org/marked/3.0.2/marked.min.js"></script>
<script src="//cdn.staticfile.org/highlight.js/11.2.0/highlight.min.js"></script>
<script src="//cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>
<script src="/markrender.min.js"></script>
<script>
    marktitle();
    markmenu(3);
    markmath();
    markhighlight();
    markgittalk();
</script>
<script src="//cdn.staticfile.org/mathjax/3.2.0/es5/latest.min.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
        MathJax.Hub.Config( { showProcessingMessages: false,messageStyle: "none", "HTML-CSS":
        { linebreaks: { automatic: false }, availableFonts: ["STIX", "TeX"]}, tex2jax:
        { inlineMath: [ ["$", "$"], ["\\(", "\\)"] ], displayMath: [ ["$$", "$$"],
        ["\\[", "\\]"] ], processEscapes: true, skipTags: ["script", "noscript",
        "style", "textarea", "pre", "code", "a"] }, TeX: { Macros: { tr: "{\\scriptscriptstyle\\mathrm{T}}",
        } } });
</script>
</body>
</html>
